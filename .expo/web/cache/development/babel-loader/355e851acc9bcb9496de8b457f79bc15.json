{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\nimport { BackgroundFetchResult, BackgroundFetchStatus } from \"./BackgroundFetch.types\";\nimport ExpoBackgroundFetch from \"./ExpoBackgroundFetch\";\nexport function getStatusAsync() {\n  return _getStatusAsync.apply(this, arguments);\n}\nfunction _getStatusAsync() {\n  _getStatusAsync = _asyncToGenerator(function* () {\n    if (Platform.OS === 'android') {\n      return BackgroundFetchStatus.Available;\n    }\n    return ExpoBackgroundFetch.getStatusAsync();\n  });\n  return _getStatusAsync.apply(this, arguments);\n}\nexport function setMinimumIntervalAsync(_x) {\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nfunction _setMinimumIntervalAsync() {\n  _setMinimumIntervalAsync = _asyncToGenerator(function* (minimumInterval) {\n    if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n      return;\n    }\n    yield ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n  });\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nexport function registerTaskAsync(_x2) {\n  return _registerTaskAsync.apply(this, arguments);\n}\nfunction _registerTaskAsync() {\n  _registerTaskAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ExpoBackgroundFetch.registerTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n    }\n    if (!TaskManager.isTaskDefined(taskName)) {\n      throw new Error(\"Task '\" + taskName + \"' is not defined. You must define a task using TaskManager.defineTask before registering.\");\n    }\n    yield ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n  });\n  return _registerTaskAsync.apply(this, arguments);\n}\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n    }\n    yield ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nexport { BackgroundFetchResult, BackgroundFetchStatus };","map":{"version":3,"mappings":";AAAA,SAASA,QAAQ,EAAEC,mBAAmB,QAAQ,mBAAmB;AACjE,OAAO,KAAKC,WAAW,MAAM,mBAAmB;AAEhD,SAEEC,qBAAqB,EACrBC,qBAAqB;AAEvB,OAAOC,mBAAmB;AAO1B,gBAAsBC,cAAc;EAAA;AAAA;AAKnC;EAAA,oCALM,aAA6B;IAClC,IAAIN,QAAQ,CAACO,EAAE,KAAK,SAAS,EAAE;MAC7B,OAAOH,qBAAqB,CAACI,SAAS;;IAExC,OAAOH,mBAAmB,CAACC,cAAc,EAAE;EAC7C,CAAC;EAAA;AAAA;AAcD,gBAAsBG,uBAAuB;EAAA;AAAA;AAM5C;EAAA,6CANM,WAAuCC,eAAuB;IACnE,IAAI,CAACL,mBAAmB,CAACI,uBAAuB,EAAE;MAChD;;IAGF,MAAMJ,mBAAmB,CAACI,uBAAuB,CAACC,eAAe,CAAC;EACpE,CAAC;EAAA;AAAA;AAwBD,gBAAsBC,iBAAiB;EAAA;AAAA;AAatC;EAAA,uCAbM,WACLC,QAAgB,EACoB;IAAA,IAApCC,8EAAkC,EAAE;IAEpC,IAAI,CAACR,mBAAmB,CAACM,iBAAiB,EAAE;MAC1C,MAAM,IAAIV,mBAAmB,CAAC,iBAAiB,EAAE,mBAAmB,CAAC;;IAEvE,IAAI,CAACC,WAAW,CAACY,aAAa,CAACF,QAAQ,CAAC,EAAE;MACxC,MAAM,IAAIG,KAAK,YACJH,QAAQ,+FAClB;;IAEH,MAAMP,mBAAmB,CAACM,iBAAiB,CAACC,QAAQ,EAAEC,OAAO,CAAC;EAChE,CAAC;EAAA;AAAA;AAQD,gBAAsBG,mBAAmB;EAAA;AAAA;AAKxC;EAAA,yCALM,WAAmCJ,QAAgB;IACxD,IAAI,CAACP,mBAAmB,CAACW,mBAAmB,EAAE;MAC5C,MAAM,IAAIf,mBAAmB,CAAC,iBAAiB,EAAE,qBAAqB,CAAC;;IAEzE,MAAMI,mBAAmB,CAACW,mBAAmB,CAACJ,QAAQ,CAAC;EACzD,CAAC;EAAA;AAAA;AAED,SAAST,qBAAqB,EAAEC,qBAAqB","names":["Platform","UnavailabilityError","TaskManager","BackgroundFetchResult","BackgroundFetchStatus","ExpoBackgroundFetch","getStatusAsync","OS","Available","setMinimumIntervalAsync","minimumInterval","registerTaskAsync","taskName","options","isTaskDefined","Error","unregisterTaskAsync"],"sourceRoot":"","sources":["../src/BackgroundFetch.ts"],"sourcesContent":["import { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport {\n  BackgroundFetchOptions,\n  BackgroundFetchResult,\n  BackgroundFetchStatus,\n} from './BackgroundFetch.types';\nimport ExpoBackgroundFetch from './ExpoBackgroundFetch';\n\n// @needsAudit\n/**\n * Gets a status of background fetch.\n * @return Returns a promise which fulfils with one of `BackgroundFetchStatus` enum values.\n */\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS === 'android') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\n// @needsAudit\n/**\n * Sets the minimum number of seconds that must elapse before another background fetch can be\n * initiated. This value is advisory only and does not indicate the exact amount of time expected\n * between fetch operations.\n *\n * > This method doesn't take any effect on Android. It is a global value which means that it can\n * overwrite settings from another application opened through Expo Go.\n *\n * @param minimumInterval Number of seconds that must elapse before another background fetch can be called.\n * @return A promise which fulfils once the minimum interval is set.\n */\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n    return;\n  }\n  // iOS only\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\n// @needsAudit\n/**\n * Registers background fetch task with given name. Registered tasks are saved in persistent storage and restored once the app is initialized.\n * @param taskName Name of the task to register. The task needs to be defined first - see [`TaskManager.defineTask`](taskmanager#defineTask)\n * for more details.\n * @param options An object containing the background fetch options.\n *\n * @example\n * ```ts\n * import * as BackgroundFetch from 'expo-background-fetch';\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, () => {\n *   try {\n *     const receivedNewData = // do your background fetch here\n *     return receivedNewData ? BackgroundFetch.BackgroundFetchResult.NewData : BackgroundFetch.BackgroundFetchResult.NoData;\n *   } catch (error) {\n *     return BackgroundFetch.Result.Failed;\n *   }\n * });\n * ```\n */\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundFetchOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Unregisters background fetch task, so the application will no longer be executing this task.\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfils when the task is fully unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport { BackgroundFetchResult, BackgroundFetchStatus, BackgroundFetchOptions };\n"]},"metadata":{},"sourceType":"module"}